{"/home/travis/build/npmtest/node-npmtest-passwordless/test.js":"/* istanbul instrument in package npmtest_passwordless */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-passwordless/lib.npmtest_passwordless.js":"/* istanbul instrument in package npmtest_passwordless */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_passwordless = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_passwordless = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-passwordless/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-passwordless && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_passwordless */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_passwordless\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_passwordless.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_passwordless.rollup.js'] =\n            local.assetsDict['/assets.npmtest_passwordless.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_passwordless.__dirname + '/lib.npmtest_passwordless.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-passwordless/node_modules/passwordless/index.js":"'use strict';\n\nmodule.exports = require('./lib');","/home/travis/build/npmtest/node-npmtest-passwordless/node_modules/passwordless/lib/index.js":"'use strict';\n\nvar Passwordless = require('./passwordless/passwordless');\n\nmodule.exports = new Passwordless();\nmodule.exports.Passwordless = Passwordless;\n","/home/travis/build/npmtest/node-npmtest-passwordless/node_modules/passwordless/lib/passwordless/passwordless.js":"'use strict';\n\nvar url = require('url');\nvar crypto = require('crypto');\nvar base58 = require('bs58');\n\n/**\n * Passwordless is a node.js module for express that allows authentication and \n * authorization without passwords but simply by sending tokens via email or \n * other means. It utilizes a very similar mechanism as many sites use for \n * resetting passwords. The module was inspired by Justin Balthrop's article \n * \"Passwords are Obsolete\"\n * @constructor\n */\nfunction Passwordless() {\n\tthis._tokenStore = undefined;\n\tthis._userProperty = undefined;\n\tthis._deliveryMethods = {};\n\tthis._defaultDelivery = undefined;\n}\n\n/**\n * Initializes Passwordless and has to be called before any methods are called\n * @param {TokenStore} tokenStore - An instance of a TokenStore used to store\n * and authenticate the generated tokens\n * @param {Object} [options]\n * @param {String} [options.userProperty] - Sets the name under which the uid \n * is stored in the http request object (default: 'user')\n * @param {Boolean} [options.allowTokenReuse] - Defines wether a token may be\n * reused by users. Enabling this option is usually required for stateless\n * operation, but generally not recommended due to the risk that others might\n * have acquired knowledge about the token while in transit (default: false)\n * @param {Boolean} [options.skipForceSessionSave] - Some session middleware\n * (especially cookie-session) does not require (and support) the forced\n * safe of a session. In this case set this option to 'true' (default: false)\n * @throws {Error} Will throw an error if called without an instantiated \n * TokenStore\n */\nPasswordless.prototype.init = function(tokenStore, options) {\n\toptions = options || {};\n\tif(!tokenStore) {\n\t\tthrow new Error('tokenStore has to be provided')\n\t}\n\n\tthis._tokenStore = tokenStore;\n\tthis._userProperty = (options.userProperty) ? options.userProperty : 'user';\n\tthis._allowTokenReuse = options.allowTokenReuse;\n\tthis._skipForceSessionSave = (options.skipForceSessionSave) ? true : false;\n}\n\n/**\n * Returns express middleware which will look for token / UID query parameters and\n * authenticate the user if they are provided and valid. A typical URL that is\n * accepted by acceptToken() does look like this:\n * http://www.example.com?token=TOKEN&uid=UID\n * Simply calls the next middleware in case no token / uid has been submitted or if\n * the supplied token / uid are not valid\n *\n * @example\n * app.use(passwordless.sessionSupport());\n * // Look for tokens in any URL requested from the server\n * app.use(passwordless.acceptToken());\n * \t\t\n * @param  {Object} [options]\n * @param  {String} [options.successRedirect] - If set, the user will be redirected\n * to the supplied URL in case of a successful authentication. If not set but the \n * authentication has been successful, the next middleware will be called. This \n * option is overwritten by option.enableOriginRedirect if set and an origin has \n * been supplied. It is strongly recommended to set this option to avoid leaking \n * valid tokens via the HTTP referrer. In case of session-less operation, though, \n * you might want to ignore this flag for efficient operation (default: null)\n * @param  {String} [options.tokenField] - The query parameter used to submit the\n * token (default: 'token')\n * @param  {String} [options.uidField] - The query parameter used to submit the \n * user id (default: 'uid')\n * @param  {Boolean} [options.allowPost] - If set, acceptToken() will also look for\n * POST parameters to contain the token and uid (default: false)\n * @param  {String} [options.failureFlash] - The error message to be flashed in case\n * a token and uid were provided but the authentication failed. Using this option\n * requires flash middleware such as connect-flash. The error message will be stored\n * as 'passwordless' (example: 'This token is not valid anymore!', default: null)\n * @param  {String} [options.successFlash] - The success message to be flashed in case\n * the supplied token and uid were accepted. Using this option requires flash middleware \n * such as connect-flash. The success message will be stored as 'passwordless-success' \n * (example: 'You are now logged in!', default: null)\n * @param  {Boolean} [options.enableOriginRedirect] - If set to true, the user will\n * be redirected to the URL he originally requested before he was redirected to the \n * login page. Requires that the URL was stored in the TokenStore when requesting a\n * token through requestToken() (default: false)\n * @return {ExpressMiddleware} Express middleware\n * @throws {Error} Will throw an error if there is no valid TokenStore, if failureFlash\n * or successFlash is used without flash middleware or allowPost is used without body \n * parser middleware\n */\nPasswordless.prototype.acceptToken = function(options) {\n\tvar self = this;\n\toptions = options || {};\n\treturn function(req, res, next) {\n\t\tif(!self._tokenStore) {\n\t\t\tthrow new Error('Passwordless is missing a TokenStore. Are you sure you called passwordless.init()?');\n\t\t}\n\n\t\tvar tokenField = (options.tokenField) ? options.tokenField : 'token';\n\t\tvar uidField = (options.uidField) ? options.uidField : 'uid';\n\n\t\tvar token = req.query[tokenField], uid = req.query[uidField];\n\t\tif(!token && !uid && options.allowPost) {\n\t\t\tif(!req.body) {\n\t\t\t\tthrow new Error('req.body does not exist: did you require middleware to accept POST data (such as body-parser) before calling acceptToken?')\n\t\t\t} else if(req.body[tokenField] && req.body[uidField]) {\n\t\t\t\ttoken = req.body[tokenField];\n\t\t\t\tuid = req.body[uidField];\n\t\t\t}\n\t\t}\n\n\t\tif((options.failureFlash || options.successFlash) && !req.flash) {\n\t\t\tthrow new Error('To use failureFlash, flash middleware is required such as connect-flash');\n\t\t}\n\n\t\tif(token && uid) {\n\t\t\tself._tokenStore.authenticate(token, uid.toString(), function(error, valid, referrer) {\n\t\t\t\tif(valid) {\n\t\t\t\t\tvar success = function() {\n\n\t\t\t\t\t\treq[self._userProperty] = uid;\n\t\t\t\t\t\tif(req.session) {\n\t\t\t\t\t\t\treq.session.passwordless = req[self._userProperty];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(options.successFlash) {\n\t\t\t\t\t\t\treq.flash('passwordless-success', options.successFlash);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(options.enableOriginRedirect && referrer) {\n\t\t\t\t\t\t\t// next() will not be called\n\t\t\t\t\t\t\treturn self._redirectWithSessionSave(req, res, next, referrer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(options.successRedirect) {\n\t\t\t\t\t\t\t// next() will not be called, and\n\t\t\t\t\t\t\t// enableOriginRedirect has priority\n\t\t\t\t\t\t\treturn self._redirectWithSessionSave(req, res, next, options.successRedirect);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Invalidate token, except allowTokenReuse has been set\n\t\t\t\t\tif(!self._allowTokenReuse) {\n\t\t\t\t\t\tself._tokenStore.invalidateUser(uid, function(err) {\n\t\t\t\t\t\t\tif(err) {\n\t\t\t\t\t\t\t\tnext('TokenStore.invalidateUser() error: ' + error);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsuccess();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsuccess();\n\t\t\t\t\t}\n\t\t\t\t} else if(error) {\n\t\t\t\t\tnext('TokenStore.authenticate() error: ' + error);\n\t\t\t\t} else if(options.failureFlash) {\n\t\t\t\t\treq.flash('passwordless', options.failureFlash);\n\t\t\t\t\tnext();\n\t\t\t\t} else {\n\t\t\t\t\tnext();\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tnext();\n\t\t}\n\t}\n}\n\n/**\n * Returns express middleware that ensures that only successfully authenticated users\n * have access to any middleware or responses that follows this middleware. Can either\n * be used for individual URLs or a certain path and any sub-elements. By default, a\n * 401 error message is returned if the user has no access to the underlying resource.\n *\n * @example\n * router.get('/admin', passwordless.restricted({ failureRedirect: '/login' }),\n * \tfunction(req, res) {\n *  \tres.render('admin', { user: req.user });\n * \t});\n * \t\t\t\n * @param  {Object} [options]\n * @param  {String} [options.failureRedirect] - If provided, the user will be redirected\n * to the given URL in case she is not authenticated. This would typically by a login \n * page (example: '/login', default: null)\n * @param  {String} [options.failureFlash] - The error message to be flashed in case\n * the user is not authenticated. Using this option requires flash middleware such as \n * connect-flash. The message will be stored as 'passwordless'. Can only be used in\n * combination with failureRedirect (example: 'No access!', default: null)\n * @param  {String} [options.originField] - If set, the originally requested URL will\n * be passed as query param (with the supplied name) to the redirect URL provided by\n * failureRedirect. Can only be used in combination with failureRedirect (example: \n * 'origin', default: null)\n * @return {ExpressMiddleware} Express middleware\n * @throws {Error} Will throw an error if failureFlash is used without flash middleware, \n * failureFlash is used without failureRedirect, or originField is used without \n * failureRedirect\n */\nPasswordless.prototype.restricted = function(options) {\n\tvar self = this;\n\treturn function(req, res, next) {\n\t\tif(req[self._userProperty]) {\n\t\t\treturn next();\n\t\t}\n\n\t\t// not authorized\n\t\toptions = options || {};\n\t\tif(options.failureRedirect) {\n\t\t\tvar queryParam = '';\n\t\t\tif(options.originField){\n\t\t\t\tvar parsedRedirectUrl = url.parse(options.failureRedirect), queryParam = '?';\n\t\t\t\tif(parsedRedirectUrl.query) {\n\t\t\t\t\tqueryParam = '&';\n\t\t\t\t}\n\t\t\t\tqueryParam += options.originField + '=' + encodeURIComponent(req.originalUrl);\n\t\t\t}\n\n\t\t\tif(options.failureFlash) {\n\t\t\t\tif(!req.flash) {\n\t\t\t\t\tthrow new Error('To use failureFlash, flash middleware is requied such as connect-flash');\n\t\t\t\t} else {\n\t\t\t\t\treq.flash('passwordless', options.failureFlash);\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\tself._redirectWithSessionSave(req, res, next, options.failureRedirect + queryParam);\n\t\t} else if(options.failureFlash) {\n\t\t\tthrow new Error('failureFlash cannot be used without failureRedirect');\n\t\t} else if(options.originField) {\n\t\t\tthrow new Error('originField cannot be used without failureRedirect');\n\t\t} else {\n\t\t\tself._send401(res, 'Provide a token');\n  \t\t}\n\t}\n}\n\n/**\n * Logs out the current user and invalidates any tokens that are still valid for the user\n *\n * @example\n * router.get('/logout', passwordless.logout( {options.successFlash: 'All done!'} ),\n * \tfunction(req, res) {\n * \t\tres.redirect('/');\n * });\n * \t\t\n * @param  {Object} [options]\n * @param  {String} [options.successFlash] - The success message to be flashed in case\n * has been logged in an the logout proceeded successfully. Using this option requires \n * flash middleware such as connect-flash. The success message will be stored as \n * 'passwordless-success'. (example: 'You are now logged in!', default: null)\n * \n * @return {ExpressMiddleware} Express middleware\n * @throws {Error} Will throw an error if successFlash is used without flash middleware\n */\nPasswordless.prototype.logout = function(options) {\n\tvar self = this;\n\treturn function(req, res, next) {\n\t\tif(req.session && req.session.passwordless) {\n\t\t\tdelete req.session.passwordless;\n\t\t}\n\t\tif(req[self._userProperty]) {\n\t\t\tself._tokenStore.invalidateUser(req[self._userProperty], function() {\n\t\t\t\tdelete req[self._userProperty];\n\t\t\t\tif(options && options.successFlash) {\n\t\t\t\t\tif(!req.flash) {\n\t\t\t\t\t\treturn next('To use successFlash, flash middleware is requied such as connect-flash');\n\t\t\t\t\t} else {\n\t\t\t\t\t\treq.flash('passwordless-success', options.successFlash);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnext();\n\t\t\t});\n\t\t} else {\n\t\t\tnext();\n\t\t}\n\t}\n}\n\n/**\n * By adding this middleware function to a route, Passwordless automatically restores\n * the logged in user from the session. In 90% of the cases, this is what is required. \n * However, Passwordless can also work without session support in a stateless mode.\n *\n * @example\n * var app = express();\n * var passwordless = new Passwordless(new DBTokenStore());\n * \t\t\n * app.use(cookieParser());\n * app.use(expressSession({ secret: '42' }));\n * \t\t\n * app.use(passwordless.sessionSupport());\n * app.use(passwordless.acceptToken());\n *\n * @return {ExpressMiddleware} Express middleware\n * @throws {Error} Will throw an error no session middleware has been supplied\n */\nPasswordless.prototype.sessionSupport = function() {\n\tvar self = this;\n\treturn function(req, res, next) {\n\t\tif(!req.session) {\n\t\t\tthrow new Error('sessionSupport requires session middleware such as expressSession');\n\t\t} else if (req.session.passwordless) {\n\t\t\treq[self._userProperty] = req.session.passwordless;\n\t\t}\n\t\tnext();\n\t}\n}\n\n/**\n * @callback getUserID\n * @param  {Object} user Contact details provided by the user (e.g. email address)\n * @param  {String} delivery Delivery method used (can be null)\n * @param  {function(error, user)} callback To be called in the format \n * callback(error, user), where error is either null or an error message and user \n * is either null if not user has been found or the user ID.\n * @param  {Object} req Express request object\n */\n\n/**\n * Requests a token from Passwordless for a specific user and calls the delivery strategy \n * to send the token to the user. Sends back a 401 error message if the user is not valid \n * or a 400 error message if no user information has been transmitted at all. By default,\n * POST params will be expected\n * \n * @example\n * router.post('/sendtoken', \n * \tpasswordless.requestToken(\n * \t\tfunction(user, delivery, callback, req) {\n * \t\t\t// usually you would want something like:\n * \t\t\tUser.find({email: user}, callback(ret) {\n * \t\t\t\tif(ret)\n * \t\t\t\t\tcallback(null, ret.id)\n * \t\t\t\telse\n * \t\t\t\t\tcallback(null, null)\n * \t\t\t})\n * \t\t}),\n * \t\tfunction(req, res) {\n * \t\t\tres.render('sent');\n * \t\t});\n *\n * @param  {getUserID} getUserID The function called to resolve the supplied user contact \n * information (e.g. email) into a proper user ID: function(user, delivery, callback, req)\n * where user contains the contact details provided, delivery the method used, callback \n * expects a call in the format callback(error, user), where error is either null or an \n * error message and user is either null if not user has been found or the user ID. req \n * contains the Express request object\n * @param  {Object} [options]\n * @param  {String} [options.failureRedirect] - If provided, the user will be redirected\n * to the given URL in case the user details were not provided or could not be validated\n * by getUserId. This could typically by a login page (example: '/login', default: null)\n * @param  {String} [options.failureFlash] - The error message to be flashed in case\n * the user details could not be validated. Using this option requires flash middleware \n * such as connect-flash. The message will be stored as 'passwordless'. Can only be used \n * in combination with failureRedirect (example: 'Your user details seem strange', \n * default: null)\n * @param  {String} [options.successFlash] - The message to be flashed in case the tokens\n * were send out successfully. Using this option requires flash middleware such as \n * connect-flash. The message will be stored as 'passwordless-success '. \n * (example: 'Your token has been send', default: null)\n * @param  {String} [options.userField] - The field which contains the user's contact \n * detail such as her email address (default: 'user')\n * @param  {String} [options.deliveryField] - The field which contains the name of the\n * delivery method to be used. Only needed if several strategies have been added with\n * addDelivery() (default: null)\n * @param  {String} [options.originField] - If set, requestToken() will look for any\n * URLs in this field that will be stored in the token database so that the user can\n * be redirected to this URL as soon as she is authenticated. Usually used to redirect \n * the user to the resource that she originally requested before being redirected to\n * the login page (default: null)\n * @param  {Boolean} [options.allowGet] - If set, requestToken() will look for GET \n * parameters instead of POST (default: false)\n * @return {ExpressMiddleware} Express middleware\n * @throws {Error} Will throw an error if failureFlash is used without flash middleware, \n * failureFlash is used without failureRedirect, successFlash is used without flash \n * middleware, no body parser is used and POST parameters are expected, or if no \n * delivery method has been added\n */\nPasswordless.prototype.requestToken = function(getUserID, options) {\n\tvar self = this;\n\toptions = options || {};\n\t\n\treturn function(req, res, next) {\n\t\tvar sendError = function(statusCode, authenticate) {\n\t\t\tif(options.failureRedirect) {\n\t\t\t\tif(options.failureFlash) {\n\t\t\t\t\treq.flash('passwordless', options.failureFlash);\n\t\t\t\t}\n\t\t\t\tself._redirectWithSessionSave(req, res, next, options.failureRedirect);\n\t\t\t} else {\n\t\t\t\tif(statusCode === 401) {\n\t\t\t\t\tself._send401(res, authenticate)\n\t\t\t\t} else {\n\t\t\t\t\tres.status(statusCode).send();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!self._tokenStore) {\n\t\t\tthrow new Error('Passwordless is missing a TokenStore. Are you sure you called passwordless.init()?');\n\t\t}\n\n\t\tif(!req.body && !options.allowGet) {\n\t\t\tthrow new Error('req.body does not exist: did you require middleware to accept POST data (such as body-parser) before calling acceptToken?')\n\t\t} else if(!self._defaultDelivery && Object.keys(self._deliveryMethods).length === 0) {\n\t\t\tthrow new Error('passwordless requires at least one delivery method which can be added using passwordless.addDelivery()');\n\t\t} else if((options.successFlash || options.failureFlash) && !req.flash) {\n\t\t\tthrow new Error('To use failureFlash or successFlash, flash middleware is required such as connect-flash');\n\t\t} else if(options.failureFlash && !options.failureRedirect) {\n\t\t\tthrow new Error('failureFlash cannot be used without failureRedirect');\n\t\t}\n\n\t\tvar userField = (options.userField) ? options.userField : 'user';\n\t\tvar deliveryField = (options.deliveryField) ? options.deliveryField : 'delivery';\n\t\tvar originField = (options.originField) ? options.originField : null;\n\n\t\tvar user, delivery, origin;\n\t\tif(req.body && req.method === \"POST\") {\n\t\t\tuser = req.body[userField];\n\t\t\tdelivery = req.body[deliveryField];\n\t\t\tif(originField) {\n\t\t\t\torigin = req.body[originField];\n\t\t\t}\n\t\t} else if(options.allowGet && req.method === \"GET\") {\n\t\t\tuser = req.query[userField];\n\t\t\tdelivery = req.query[deliveryField];\n\t\t\tif(originField) {\n\t\t\t\torigin = req.query[originField];\n\t\t\t}\n\t\t}\n\n\t\tvar deliveryMethod = self._defaultDelivery;\n\t\tif(delivery && self._deliveryMethods[delivery]) {\n\t\t\tdeliveryMethod = self._deliveryMethods[delivery];\n\t\t}\n\n\t\tif(typeof user === 'string' && user.length === 0) {\n\t\t\treturn sendError(401, 'Provide a valid user');\n\t\t} else if(!deliveryMethod || !user) {\n\t\t\treturn sendError(400);\n\t\t}\n\n\t\tgetUserID(user, delivery, function(uidError, uid) {\n\t\t\tif(uidError) {\n\t\t\t\tnext(new Error('Error on the user verification layer: ' + uidError));\n\t\t\t} else if(uid) {\n\t\t\t\tvar token;\n\t\t\t\ttry {\n\t\t\t\t\tif(deliveryMethod.options.numberToken && deliveryMethod.options.numberToken.max) {\n\t\t\t\t\t\ttoken = self._generateNumberToken(deliveryMethod.options.numberToken.max);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttoken = (deliveryMethod.options.tokenAlgorithm || self._generateToken())();\n\t\t\t\t\t}\n\t\t\t\t} catch(err) {\n\t\t\t\t\tnext(new Error('Error while generating a token: ' + err));\n\t\t\t\t}\n\t\t\t\tvar ttl = deliveryMethod.options.ttl || 60 * 60 * 1000;\n\n\t\t\t\tself._tokenStore.storeOrUpdate(token, uid.toString(), ttl, origin, function(storeError) {\n\t\t\t\t\tif(storeError) {\n\t\t\t\t\t\tnext(new Error('Error on the storage layer: ' + storeError));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdeliveryMethod.sendToken(token, uid, user, function(deliveryError) {\n\t\t\t\t\t\t\tif(deliveryError) {\n\t\t\t\t\t\t\t\tnext(new Error('Error on the deliveryMethod delivery layer: ' + deliveryError));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif(!req.passwordless) {\n\t\t\t\t\t\t\t\t\treq.passwordless = {};\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treq.passwordless.uidToAuth = uid;\n\t\t\t\t\t\t\t\tif(options.successFlash) {\n\t\t\t\t\t\t\t\t\treq.flash('passwordless-success', options.successFlash);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, req)\t\t\n\t\t\t\t\t}\t\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tsendError(401, 'Provide a valid user');\n\t\t\t}\n\t\t}, req)\n\t}\n}\n\n/**\n * @callback sendToken\n * @param  {String} tokenToSend The token to send\n * @param  {Object} uidToSend The UID that has to be part of the token URL\n * @param  {String} recipient the target such as an email address or a phone number \n * depending on the user input\n * @param  {function(error)} callback Has to be called either with no parameters or \n * with callback({String}) in case of any issues during delivery\n * @param  {Object} req The request object\n */\n\n/**\n * Adds a new delivery method to Passwordless used to transmit tokens to the user. This could, \n * for example, be an email client or a sms client. If only one method is used, no name has to \n * provided as it will be the default delivery method. If several methods are used and added, \n * they will have to be named.\n *\n * @example\n * passwordless.init(new MongoStore(pathToMongoDb));\n * passwordless.addDelivery(\n * \tfunction(tokenToSend, uidToSend, recipient, callback, req) {\n * \t\t// Send out token\n * \t\tsmtpServer.send({\n * \t\t\ttext:    'Hello!\\nYou can now access your account here: ' \n * \t\t\t\t+ host + '?token=' + tokenToSend + '&uid=' + encodeURIComponent(uidToSend), \n * \t\t\tfrom:    yourEmail, \n * \t\t\tto:      recipient,\n * \t\t\tsubject: 'Token for ' + host\n * \t\t}, function(err, message) { \n * \t\t\tif(err) {\n * \t\t\t\tconsole.log(err);\n * \t\t\t}\n * \t\t\tcallback(err);\n * \t\t});\n * \t});\n * \t\n * @param {String} [name] - Name of the strategy. Not needed if only one method is added\n * @param {sendToken} sendToken - Method that will be called as\n * function(tokenToSend, uidToSend, recipient, callback, req) to transmit the token to the \n * user. tokenToSend contains the token, uidToSend the UID that has to be part of the \n * token URL, recipient contains the target such as an email address or a phone number \n * depending on the user input, and callback has to be called either with no parameters \n * or with callback({String}) in case of any issues during delivery\n * @param  {Object} [options]\n * @param  {Number} [options.ttl] - Duration in ms that the token shall be valid \n * (example: 1000*60*30, default: 1 hour)\n * @param  {function()} [options.tokenAlgorithm] - The algorithm used to generate a token. \n * Function shall return the token in sync mode (default: Base58 token)\n * @param  {Number} [options.numberToken.max] - Overwrites the default token generator\n * by a random number generator which generates numbers between 0 and max. Cannot be used\n * together with options.tokenAlgorithm\n */\nPasswordless.prototype.addDelivery = function(name, sendToken, options) {\n\t// So that add can be called with (sendToken [, options])\n\tvar defaultUsage = false;\n\tif(typeof name === 'function') {\n\t\toptions = sendToken;\n\t\tsendToken = name;\n\t\tname = undefined;\n\t\tdefaultUsage = true;\n\t}\n\toptions = options || {};\n\n\tif(typeof sendToken !== 'function' || typeof options !== 'object' \n\t\t|| (name && typeof name !== 'string')) {\n\t\tthrow new Error('Passwordless.addDelivery called with wrong parameters');\n\t} else if((options.ttl && typeof options.ttl !== 'number') || \n\t\t(options.tokenAlgorithm && typeof options.tokenAlgorithm !== 'function') ||\n\t\t(options.numberToken && (!options.numberToken.max || typeof options.numberToken.max !== 'number'))) {\n\t\tthrow new Error('One of the provided options is of the wrong format');\n\t} else if(options.tokenAlgorithm && options.numberToken) {\n\t\tthrow new Error('options.tokenAlgorithm cannot be used together with options.numberToken');\n\t} else if(this._defaultDelivery) {\n\t\tthrow new Error('Only one default delivery method shall be defined and not be mixed up with named methods. Use named delivery methods instead')\n\t} else if(defaultUsage && Object.keys(this._deliveryMethods).length > 0) {\n\t\tthrow new Error('Default delivery methods and named delivery methods shall not be mixed up');\n\t}\n\n\tvar method = {\n\t\t\tsendToken: sendToken,\n\t\t\toptions: options\n\t\t};\n\tif(defaultUsage) {\n\t\tthis._defaultDelivery = method;\n\t} else {\n\t\tif(this._deliveryMethods[name]) {\n\t\t\tthrow new Error('Only one named delivery method with the same name shall be added')\n\t\t} else {\n\t\t\tthis._deliveryMethods[name] = method;\n\t\t}\n\t}\n}\n\n/**\n * Sends a 401 error message back to the user\n * @param  {Object} res - Node's http res object\n * @private\n */\nPasswordless.prototype._send401 = function(res, authenticate) {\n\tres.statusCode = 401;\n\tif(authenticate) {\n\t\tres.setHeader('WWW-Authenticate', authenticate);\n\t}\n\tres.end('Unauthorized');\n}\n\n/**\n * Avoids a bug in express that might lead to a redirect\n * before the session is actually saved\n * @param  {Object} req - Node's http req object\n * @param  {Object} res - Node's http res object\n * @param  {Function} next - Middleware callback\n * @param  {String} target - URL to redirect to\n * @private\n */\nPasswordless.prototype._redirectWithSessionSave = function(req, res, next, target) {\n\tif (!req.session || this._skipForceSessionSave) {\n\t\treturn res.redirect(target);\n\t} else {\n\t\treq.session.save(function(err) {\n\t\t\tif (err) {\n\t\t\t\treturn next(err);\n\t\t\t} else {\n\t\t\t\tres.redirect(target);\n\t\t\t}\n\t\t});\n\t}\n};\n\n/**\n * Generates a random token using Node's crypto rng\n * @param  {Number} randomBytes - Random bytes to be generated\n * @return {function()} token-generator function\n * @throws {Error} Will throw an error if there is no sufficient\n * entropy accumulated\n * @private\n */\nPasswordless.prototype._generateToken = function(randomBytes) {\n\trandomBytes = randomBytes || 16;\n\treturn function() {\n\t\tvar buf = crypto.randomBytes(randomBytes);\n\t\treturn base58.encode(buf);\n\t}\n};\n\n/**\n * Generates a strong random number between 0 and a maximum value. The\n * maximum value cannot exceed 2^32\n * @param  {Number} max - Maximum number to be generated\n * @return {Number} Random number between 0 and max\n * @throws {Error} Will throw an error if there is no sufficient\n * entropy accumulated\n * @private\n */\nPasswordless.prototype._generateNumberToken = function(max) {\n\tvar buf = crypto.randomBytes(4);\n\treturn Math.floor(buf.readUInt32BE(0)%max).toString();\n};\n\nmodule.exports = Passwordless;\n\n/** \n * Express middleware\n * @name ExpressMiddleware\n * @function\n * @param {Object} req\n * @param {Object} res\n * @param {Object} next\n */\n","/home/travis/build/npmtest/node-npmtest-passwordless/node_modules/passwordless/Gruntfile.js":"module.exports = function(grunt) {\n\n\tgrunt.loadNpmTasks('grunt-mocha-test');\n\tgrunt.loadNpmTasks('grunt-jsdoc');\n\tgrunt.loadNpmTasks('grunt-contrib-clean');\n\n\tgrunt.initConfig({\n\t\tclean: {\n\t\t\tdocs: ['docs']\n\t\t},\n\t\tmochaTest: {\n\t\t\ttest: {\n\t\t\t\toptions: {\n\t\t\t\t\treporter: 'spec'\n\t\t\t\t},\n\t\t\t\tsrc: ['test/**/*.test.js']\n\t\t\t}\n\t\t},\n\t\tjsdoc : {\n\t\t\tdist : {\n\t\t\t\tsrc: ['lib/passwordless/passwordless.js'], \n\t\t\t\toptions: {\n\t\t\t\t\tdestination: 'docs'\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tgrunt.registerTask('test', ['mochaTest']);\n\tgrunt.registerTask('docs', ['clean:docs', 'jsdoc']);\n};"}